下面是目前「C 表示法」與「快照（snapshot）系統」的**統整規格**，給第一次接手的人能快速上手。

# C（Computing input）表示法

## 語法

* **三段式**：`C(l)(m)(r)`，其中 `l,m,r ∈ {0,1}`

  * `l`：套用到「索引 < k」的 cell 值
  * `m`：套用到「索引 = k」的 cell 值
  * `r`：套用到「索引 > k」的 cell 值
* 不再使用 `C(R)N`；其等價情形用 `C(0)(0)(0)`（全 0）或 `C(1)(1)(1)`（全 1）表達。

## 意義（在位址 k 計算）

給定目前要套用的索引 `k`（見下方「C 的執行時機」）與 cell 數量 `Ncells=R+1`：

```
Ci(k) = l,  若 i < k
      = m,  若 i = k
      = r,  若 i > k
```

> C 只影響 **computing input**，不直接改動記憶體 D 的位元值。

## C 的執行時機與「狀態保留」

* **C 是「全域狀態」**：一旦在某步執行了 C，之後的快照都**沿用**這個 C，直到下一次 C 再度覆寫。
* **何時執行 C？**
  在一個 element 的掃描過程中，**每一個實際被處理的位址**都會「執行一次 C（若該 element 內有 C 操作）」，以當下位址作為 `k` 來重算整列 C，並覆寫全域 C。

  * 這包含：**before 區段**的每個位址、**在 r** 的 C 操作、以及 **after 區段**的每個位址。
  * 若該 element **沒有 C 操作**，則 C 完全不變（沿用上一個元素留下的全域 C；若之前從未執行過 C，則 C 顯示為 `X`）。

---

# D（Memory）與操作語義

* `W0 / W1`：在**目前位址**寫入 0/1（會改變 D）。
* `R0 / R1`：在**目前位址**做 read‑check（不改變 D，只是流程步）。
* C 與 D 是**兩個獨立的通道**：
  `W/R` 只影響 **D**；`C` 只重算 **C 列**；彼此不直接改值。

---

# 元素（element）與掃描方向

* 元素格式：`a{ ... }`、`b{ ... }`、`d{ ... }`

  * `a`、`b` 視為 **向上（Up, 0→R）**；`d` 為 **向下（Down, R→0）**。
* 給定固定的觀測索引 `r`（例如 `r=1`），每個 element 以三個階段處理位址：

  * **before**：

    * `Up`：依序處理位址 `0,1,...,r-1`
    * `Down`：依序處理位址 `R, R-1, ..., r+1`
  * **at**：處理位址 `r`
  * **after**：

    * `Up`：依序處理位址 `r+1, r+2, ..., R`
    * `Down`：依序處理位址 `r-1, r-2, ..., 0`
* 在「處理某個位址」時，會把該 element 內的所有 `W/R` 依序作用在那個位址；若該 element 內含 `C(l)(m)(r)`，也會以**該位址當作 k** 重新計算 C 並覆寫到**全域 C**。

---

# 快照（snapshot）規則與輸出格式

## 何時拍快照

對每個 element，我們在**固定觀測索引 r**位置**逐步執行其 op 並拍快照**：

1. **PRE**：before 區段完成後、進入 r 之前，先拍一張（D 反映 before 之後的狀態；C 為目前全域 C）
2. **after 每個 op**（在 r 位置）：`R? / W? / C(...)` 每執行一個就拍一張
3. 不在 r 的 before/after 位址**不拍快照**，但它們**會更新** D（在該位址）與全域 C（若有 C）

> 因此快照序列對齊你想要的格式：
> `x{ (id_PRE) ...op1(id) ...op2(id) ... }`
> 並以兩列呈現：**第一列 D，第二列 C**。

## 輸出外觀

* 每個 element 先印一行標頭，包含 element 內各快照的 `(id)` 與 op 名稱，例如：

  ```
  a{ (4) R0 (5) W1 (6) C(0)(1)(1) (7) }
  ```

  其中 `(4)` 是 PRE 的 id，`(5)(6)(7)` 分別對應在 r 位置執行 `R0 / W1 / C(0)(1)(1)` 之後的快照。
* 接著印兩列（欄寬對齊）：

  ```
  (4) {D,D,D}   (5) {D,D,D}   (6) {D,D,D}   (7) {D,D,D}
      {C,C,C}       {C,C,C}       {C,C,C}       {C,C,C}
  ```

  * D 列：每個 `(id)` 對應一個 `{…}`（X 表示尚未被寫入的 D）
  * C 列：同欄位寬度對齊，顯示當下**全域 C**（若從未執行過 C，顯示 `X`）

---

# 關鍵行為回顧（用你的例子驗證）

假設 3 cells、`r=1`：

### 例 1

```
b{ (1) W0 (2) C(0)(0)(0) (3) }
a{ (4) R0 (5) W1 (6) C(0)(1)(1) (7) }
```

* 第一個 element 在 r=1 的 before（位址 0）處理完後，PRE(1)；在 r 執行 `W0`、之後執行 `C(0)(0)(0)`，故全域 C 變成 `{0,0,0}`。
* 第二個 element 的 before 會先處理位址 **0**，而它**包含 `C(0)(1)(1)`**，所以在位址 0 以 `k=0` 計算 → **全域 C 變 `{1,1,1}`**。
  因此：

  ```
  a{ (4) R0 (5) W1 (6) C(0)(1)(1) (7) }

  (4) {1,0,0} (5) {1,0,0} (6) {1,1,0} (7) {1,1,0}
       {1,1,1}     {1,1,1}     {1,1,1}     {0,1,1}   ← 在 (7) 才於 r 套 C，C 變 {0,1,1}
  ```

### 例 2

```
d{ (12) C(1)(1)(0) (13) R0 (14) W1 (15) }
```

* `d` 的 before 會先處理位址 **2**；若 element 內含 C，則以 `k=2` 計算 → C 更新一次；
* 在 r（=1）位置執行 op 拍 (13)(14)…；
* after（位址 0）若 element 仍含 C，會以 `k=0` 再更新一次 C；
* 下一個 element 若不含 C，會沿用這裡最後一次的全域 C。

---

# 參數化與初始化

* **cells 數量**與**觀測 r**皆可參數化（CLI：`--cells N --r K`）。
* 初始 **D** 為 `{X,…,X}`（未寫入），初始 **C** 亦為 `{X,…,X}`，直到第一次 C 被執行。

---

# 常見誤解 & 注意事項

1. **C 不看方向形狀**：`C(l)(m)(r)` 的形狀只由 `(l,m,r)` 與 `k` 決定；a/d 僅決定**掃描順序**（進而決定 before/after 會觸發哪些位址的 C 執行）。
2. **沒有 C 的 element** 不會改變 C；但 D 仍會因 W 改變。
3. **多個 C** 在同一個 element 內：每到一個「被處理的位址 k」，**依出現順序逐一套用**，最後一個決定當前全域 C。
4. **邊界（k=0 或 k=R）** 無需特判：照 `<k / =k / >k` 直接套即可。
5. **X 的含義**：只代表「尚未定義／未被寫過」；一旦 C 或 D 有值，快照以 0/1 顯示。

---

# 一句話總結

> **C(l)(m)(r)** 在每個「實際被處理的位址 k」被執行時，依 `(l,m,r)` 和 `k` 立即重算整列 C 成為**全域狀態**；快照在 r 處逐步顯示 D 與當下全域 C；a/d 只影響位址處理順序（因此影響 C 被更新的時機），但不改變 `C(l)(m)(r)` 的形狀定義。
